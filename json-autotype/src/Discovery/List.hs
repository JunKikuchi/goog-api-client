
{-# LANGUAGE TemplateHaskell     #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RecordWildCards     #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TypeOperators       #-}
{-# LANGUAGE DeriveGeneric       #-}
-- | DO NOT EDIT THIS FILE MANUALLY!
--   It was automatically generated by `json-autotype`.
module Discovery.List where
import RIO
import RIO.ByteString.Lazy as BSL
-- import           System.Exit        (exitFailure, exitSuccess)
-- import           System.IO          (stderr, hPutStrLn)
-- import qualified Data.ByteString.Lazy.Char8 as BSL
-- import           System.Environment (getArgs)
import           Control.Monad      (forM_, mzero, join)
import           Control.Applicative
import           Data.Aeson.AutoType.Alternative
import           Data.Aeson(eitherDecode, Value(..), FromJSON(..), ToJSON(..),pairs,(.:), (.:?), (.=), object)
import           Data.Monoid((<>))
-- import           Data.Text (Text)
import qualified GHC.Generics
{-# ANN module ("HLint: ignore" :: String) #-}

data Icons = Icons { 
    iconsX16 :: Text,
    iconsX32 :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Icons where
  parseJSON (Object v) = Icons <$> v .:  "x16" <*> v .:  "x32"
  parseJSON _          = mzero


instance ToJSON Icons where
  toJSON     (Icons {..}) = object ["x16" .= iconsX16, "x32" .= iconsX32]
  toEncoding (Icons {..}) = pairs  ("x16" .= iconsX16<>"x32" .= iconsX32)


data ItemsElt = ItemsElt { 
    itemsEltDiscoveryLink :: (Maybe (Text:|:[(Maybe Value)])),
    itemsEltPreferred :: Bool,
    itemsEltKind :: Text,
    itemsEltIcons :: Icons,
    itemsEltName :: Text,
    itemsEltVersion :: Text,
    itemsEltDocumentationLink :: Text,
    itemsEltId :: Text,
    itemsEltLabels :: (Maybe ([Text])),
    itemsEltTitle :: Text,
    itemsEltDescription :: Text,
    itemsEltDiscoveryRestUrl :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON ItemsElt where
  parseJSON (Object v) = ItemsElt <$> v .:? "discoveryLink" <*> v .:  "preferred" <*> v .:  "kind" <*> v .:  "icons" <*> v .:  "name" <*> v .:  "version" <*> v .:  "documentationLink" <*> v .:  "id" <*> v .:? "labels" <*> v .:  "title" <*> v .:  "description" <*> v .:  "discoveryRestUrl"
  parseJSON _          = mzero


instance ToJSON ItemsElt where
  toJSON     (ItemsElt {..}) = object ["discoveryLink" .= itemsEltDiscoveryLink, "preferred" .= itemsEltPreferred, "kind" .= itemsEltKind, "icons" .= itemsEltIcons, "name" .= itemsEltName, "version" .= itemsEltVersion, "documentationLink" .= itemsEltDocumentationLink, "id" .= itemsEltId, "labels" .= itemsEltLabels, "title" .= itemsEltTitle, "description" .= itemsEltDescription, "discoveryRestUrl" .= itemsEltDiscoveryRestUrl]
  toEncoding (ItemsElt {..}) = pairs  ("discoveryLink" .= itemsEltDiscoveryLink<>"preferred" .= itemsEltPreferred<>"kind" .= itemsEltKind<>"icons" .= itemsEltIcons<>"name" .= itemsEltName<>"version" .= itemsEltVersion<>"documentationLink" .= itemsEltDocumentationLink<>"id" .= itemsEltId<>"labels" .= itemsEltLabels<>"title" .= itemsEltTitle<>"description" .= itemsEltDescription<>"discoveryRestUrl" .= itemsEltDiscoveryRestUrl)


data List = List { 
    listKind :: Text,
    listItems :: [ItemsElt],
    listDiscoveryVersion :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON List where
  parseJSON (Object v) = List <$> v .:  "kind" <*> v .:  "items" <*> v .:  "discoveryVersion"
  parseJSON _          = mzero


instance ToJSON List where
  toJSON     (List {..}) = object ["kind" .= listKind, "items" .= listItems, "discoveryVersion" .= listDiscoveryVersion]
  toEncoding (List {..}) = pairs  ("kind" .= listKind<>"items" .= listItems<>"discoveryVersion" .= listDiscoveryVersion)





-- | Use parser to get List object
{--
parse :: FilePath -> IO List
parse filename = do
    input <- BSL.readFile filename
    case eitherDecode input of
      Left errTop -> fatal $ case (eitherDecode input :: Either String Value) of
                           Left  err -> "Invalid JSON file: " ++ filename ++ "\n   " ++ err
                           Right _   -> "Mismatched JSON value from file: " ++ filename
                                     ++ "\n" ++ errTop
      Right r     -> return (r :: List)
  where
    fatal :: String -> IO a
    fatal msg = do hPutStrLn stderr msg
                   exitFailure

-- | For quick testing
main :: IO ()
main = do
  filenames <- getArgs
  forM_ filenames (\f -> parse f >>= (\p -> p `seq` putStrLn $ "Successfully parsed " ++ f))
  exitSuccess

--}
