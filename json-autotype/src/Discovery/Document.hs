
{-# LANGUAGE TemplateHaskell     #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RecordWildCards     #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TypeOperators       #-}
{-# LANGUAGE DeriveGeneric       #-}
-- | DO NOT EDIT THIS FILE MANUALLY!
--   It was automatically generated by `json-autotype`.
module Discovery.Document where
import RIO
import RIO.ByteString.Lazy as BSL
-- import           System.Exit        (exitFailure, exitSuccess)
-- import           System.IO          (stderr, hPutStrLn)
-- import qualified Data.ByteString.Lazy.Char8 as BSL
-- import           System.Environment (getArgs)
import           Control.Monad      (forM_, mzero, join)
import           Control.Applicative
import           Data.Aeson.AutoType.Alternative
import           Data.Aeson(eitherDecode, Value(..), FromJSON(..), ToJSON(..),pairs,(.:), (.:?), (.=), object)
import           Data.Monoid((<>))
-- import           Data.Text (Text)
import qualified GHC.Generics
{-# ANN module ("HLint: ignore" :: String) #-}

data CreatedBefore = CreatedBefore { 
    createdBeforeFormat :: (Maybe (Text:|:[(Maybe Value)])),
    createdBeforeType :: Text,
    createdBeforeDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON CreatedBefore where
  parseJSON (Object v) = CreatedBefore <$> v .:? "format" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON CreatedBefore where
  toJSON     (CreatedBefore {..}) = object ["format" .= createdBeforeFormat, "type" .= createdBeforeType, "description" .= createdBeforeDescription]
  toEncoding (CreatedBefore {..}) = pairs  ("format" .= createdBeforeFormat<>"type" .= createdBeforeType<>"description" .= createdBeforeDescription)


data Resource = Resource { 
    resourceRef :: Text,
    resourceDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Resource where
  parseJSON (Object v) = Resource <$> v .:  "$ref" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Resource where
  toJSON     (Resource {..}) = object ["$ref" .= resourceRef, "description" .= resourceDescription]
  toEncoding (Resource {..}) = pairs  ("$ref" .= resourceRef<>"description" .= resourceDescription)


data LogObjectPrefix = LogObjectPrefix { 
    logObjectPrefixType :: Text,
    logObjectPrefixDescription :: (Maybe (Text:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON LogObjectPrefix where
  parseJSON (Object v) = LogObjectPrefix <$> v .:  "type" <*> v .:? "description"
  parseJSON _          = mzero


instance ToJSON LogObjectPrefix where
  toJSON     (LogObjectPrefix {..}) = object ["type" .= logObjectPrefixType, "description" .= logObjectPrefixDescription]
  toEncoding (LogObjectPrefix {..}) = pairs  ("type" .= logObjectPrefixType<>"description" .= logObjectPrefixDescription)


data Items = Items { 
    itemsRef :: (Maybe (Text:|:[(Maybe Value)])),
    itemsItems :: (Maybe (Items:|:[(Maybe Value)])),
    itemsType :: (Maybe (Text:|:[(Maybe Value)])),
    itemsDescription :: (Maybe (Text:|:[(Maybe Value)])),
    itemsProperties :: (Maybe (Properties:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Items where
  parseJSON (Object v) = Items <$> v .:? "$ref" <*> v .:? "items" <*> v .:? "type" <*> v .:? "description" <*> v .:? "properties"
  parseJSON _          = mzero


instance ToJSON Items where
  toJSON     (Items {..}) = object ["$ref" .= itemsRef, "items" .= itemsItems, "type" .= itemsType, "description" .= itemsDescription, "properties" .= itemsProperties]
  toEncoding (Items {..}) = pairs  ("$ref" .= itemsRef<>"items" .= itemsItems<>"type" .= itemsType<>"description" .= itemsDescription<>"properties" .= itemsProperties)


data DefaultObjectAcl = DefaultObjectAcl { 
    defaultObjectAclItems :: Items:|:[(Maybe Value)],
    defaultObjectAclType :: Text,
    defaultObjectAclDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON DefaultObjectAcl where
  parseJSON (Object v) = DefaultObjectAcl <$> v .:  "items" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON DefaultObjectAcl where
  toJSON     (DefaultObjectAcl {..}) = object ["items" .= defaultObjectAclItems, "type" .= defaultObjectAclType, "description" .= defaultObjectAclDescription]
  toEncoding (DefaultObjectAcl {..}) = pairs  ("items" .= defaultObjectAclItems<>"type" .= defaultObjectAclType<>"description" .= defaultObjectAclDescription)


data Logging = Logging { 
    loggingType :: Text,
    loggingDescription :: Text,
    loggingProperties :: Properties:|:[(Maybe Value)]
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Logging where
  parseJSON (Object v) = Logging <$> v .:  "type" <*> v .:  "description" <*> v .:  "properties"
  parseJSON _          = mzero


instance ToJSON Logging where
  toJSON     (Logging {..}) = object ["type" .= loggingType, "description" .= loggingDescription, "properties" .= loggingProperties]
  toEncoding (Logging {..}) = pairs  ("type" .= loggingType<>"description" .= loggingDescription<>"properties" .= loggingProperties)


data Generation = Generation { 
    generationLocation :: (Maybe (Text:|:[(Maybe Value)])),
    generationFormat :: Text,
    generationType :: Text,
    generationDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Generation where
  parseJSON (Object v) = Generation <$> v .:? "location" <*> v .:  "format" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Generation where
  toJSON     (Generation {..}) = object ["location" .= generationLocation, "format" .= generationFormat, "type" .= generationType, "description" .= generationDescription]
  toEncoding (Generation {..}) = pairs  ("location" .= generationLocation<>"format" .= generationFormat<>"type" .= generationType<>"description" .= generationDescription)


data Annotations = Annotations { 
    annotationsRequired :: [Text]
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Annotations where
  parseJSON (Object v) = Annotations <$> v .:  "required"
  parseJSON _          = mzero


instance ToJSON Annotations where
  toJSON     (Annotations {..}) = object ["required" .= annotationsRequired]
  toEncoding (Annotations {..}) = pairs  ("required" .= annotationsRequired)


data PayloadFormat = PayloadFormat { 
    payloadFormatAnnotations :: Annotations,
    payloadFormatDefault :: Text,
    payloadFormatType :: Text,
    payloadFormatDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON PayloadFormat where
  parseJSON (Object v) = PayloadFormat <$> v .:  "annotations" <*> v .:  "default" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON PayloadFormat where
  toJSON     (PayloadFormat {..}) = object ["annotations" .= payloadFormatAnnotations, "default" .= payloadFormatDefault, "type" .= payloadFormatType, "description" .= payloadFormatDescription]
  toEncoding (PayloadFormat {..}) = pairs  ("annotations" .= payloadFormatAnnotations<>"default" .= payloadFormatDefault<>"type" .= payloadFormatType<>"description" .= payloadFormatDescription)


data Kind = Kind { 
    kindDefault :: Text,
    kindType :: Text,
    kindDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Kind where
  parseJSON (Object v) = Kind <$> v .:  "default" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Kind where
  toJSON     (Kind {..}) = object ["default" .= kindDefault, "type" .= kindType, "description" .= kindDescription]
  toEncoding (Kind {..}) = pairs  ("default" .= kindDefault<>"type" .= kindType<>"description" .= kindDescription)


data Acl = Acl { 
    aclAnnotations :: Annotations:|:[(Maybe Value)],
    aclItems :: Items:|:[(Maybe Value)],
    aclType :: Text,
    aclDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Acl where
  parseJSON (Object v) = Acl <$> v .:  "annotations" <*> v .:  "items" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Acl where
  toJSON     (Acl {..}) = object ["annotations" .= aclAnnotations, "items" .= aclItems, "type" .= aclType, "description" .= aclDescription]
  toEncoding (Acl {..}) = pairs  ("annotations" .= aclAnnotations<>"items" .= aclItems<>"type" .= aclType<>"description" .= aclDescription)


data DestinationObject = DestinationObject { 
    destinationObjectLocation :: (Maybe (Text:|:[(Maybe Value)])),
    destinationObjectRequired :: (Maybe (Bool:|:[(Maybe Value)])),
    destinationObjectType :: Text,
    destinationObjectDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON DestinationObject where
  parseJSON (Object v) = DestinationObject <$> v .:? "location" <*> v .:? "required" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON DestinationObject where
  toJSON     (DestinationObject {..}) = object ["location" .= destinationObjectLocation, "required" .= destinationObjectRequired, "type" .= destinationObjectType, "description" .= destinationObjectDescription]
  toEncoding (DestinationObject {..}) = pairs  ("location" .= destinationObjectLocation<>"required" .= destinationObjectRequired<>"type" .= destinationObjectType<>"description" .= destinationObjectDescription)


data Role = Role { 
    roleAnnotations :: Annotations:|:[(Maybe Value)],
    roleType :: Text,
    roleDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Role where
  parseJSON (Object v) = Role <$> v .:  "annotations" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Role where
  toJSON     (Role {..}) = object ["annotations" .= roleAnnotations, "type" .= roleType, "description" .= roleDescription]
  toEncoding (Role {..}) = pairs  ("annotations" .= roleAnnotations<>"type" .= roleType<>"description" .= roleDescription)


data CustomAttributes = CustomAttributes { 
    customAttributesAdditionalProperties :: LogObjectPrefix:|:[(Maybe Value)],
    customAttributesType :: Text,
    customAttributesDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON CustomAttributes where
  parseJSON (Object v) = CustomAttributes <$> v .:  "additionalProperties" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON CustomAttributes where
  toJSON     (CustomAttributes {..}) = object ["additionalProperties" .= customAttributesAdditionalProperties, "type" .= customAttributesType, "description" .= customAttributesDescription]
  toEncoding (CustomAttributes {..}) = pairs  ("additionalProperties" .= customAttributesAdditionalProperties<>"type" .= customAttributesType<>"description" .= customAttributesDescription)


data Name = Name { 
    nameAnnotations :: (Maybe (Annotations:|:[(Maybe Value)])),
    nameLocation :: (Maybe (Text:|:[(Maybe Value)])),
    nameType :: Text,
    nameDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Name where
  parseJSON (Object v) = Name <$> v .:? "annotations" <*> v .:? "location" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Name where
  toJSON     (Name {..}) = object ["annotations" .= nameAnnotations, "location" .= nameLocation, "type" .= nameType, "description" .= nameDescription]
  toEncoding (Name {..}) = pairs  ("annotations" .= nameAnnotations<>"location" .= nameLocation<>"type" .= nameType<>"description" .= nameDescription)


data RewriteToken = RewriteToken { 
    rewriteTokenLocation :: (Maybe (Text:|:[(Maybe Value)])),
    rewriteTokenType :: Text,
    rewriteTokenDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON RewriteToken where
  parseJSON (Object v) = RewriteToken <$> v .:? "location" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON RewriteToken where
  toJSON     (RewriteToken {..}) = object ["location" .= rewriteTokenLocation, "type" .= rewriteTokenType, "description" .= rewriteTokenDescription]
  toEncoding (RewriteToken {..}) = pairs  ("location" .= rewriteTokenLocation<>"type" .= rewriteTokenType<>"description" .= rewriteTokenDescription)


data Metadata = Metadata { 
    metadataRef :: (Maybe (Text:|:[(Maybe Value)])),
    metadataAdditionalProperties :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    metadataType :: (Maybe (Text:|:[(Maybe Value)])),
    metadataDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Metadata where
  parseJSON (Object v) = Metadata <$> v .:? "$ref" <*> v .:? "additionalProperties" <*> v .:? "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Metadata where
  toJSON     (Metadata {..}) = object ["$ref" .= metadataRef, "additionalProperties" .= metadataAdditionalProperties, "type" .= metadataType, "description" .= metadataDescription]
  toEncoding (Metadata {..}) = pairs  ("$ref" .= metadataRef<>"additionalProperties" .= metadataAdditionalProperties<>"type" .= metadataType<>"description" .= metadataDescription)


data Permissions = Permissions { 
    permissionsLocation :: (Maybe (Text:|:[(Maybe Value)])),
    permissionsItems :: (Maybe (Items:|:[(Maybe Value)])),
    permissionsRequired :: (Maybe (Bool:|:[(Maybe Value)])),
    permissionsType :: Text,
    permissionsRepeated :: (Maybe (Bool:|:[(Maybe Value)])),
    permissionsDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Permissions where
  parseJSON (Object v) = Permissions <$> v .:? "location" <*> v .:? "items" <*> v .:? "required" <*> v .:  "type" <*> v .:? "repeated" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Permissions where
  toJSON     (Permissions {..}) = object ["location" .= permissionsLocation, "items" .= permissionsItems, "required" .= permissionsRequired, "type" .= permissionsType, "repeated" .= permissionsRepeated, "description" .= permissionsDescription]
  toEncoding (Permissions {..}) = pairs  ("location" .= permissionsLocation<>"items" .= permissionsItems<>"required" .= permissionsRequired<>"type" .= permissionsType<>"repeated" .= permissionsRepeated<>"description" .= permissionsDescription)


data Condition = Condition { 
    conditionRef :: (Maybe (Text:|:[(Maybe Value)])),
    conditionType :: (Maybe (Text:|:[(Maybe Value)])),
    conditionDescription :: Text,
    conditionProperties :: (Maybe (Properties:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Condition where
  parseJSON (Object v) = Condition <$> v .:? "$ref" <*> v .:? "type" <*> v .:  "description" <*> v .:? "properties"
  parseJSON _          = mzero


instance ToJSON Condition where
  toJSON     (Condition {..}) = object ["$ref" .= conditionRef, "type" .= conditionType, "description" .= conditionDescription, "properties" .= conditionProperties]
  toEncoding (Condition {..}) = pairs  ("$ref" .= conditionRef<>"type" .= conditionType<>"description" .= conditionDescription<>"properties" .= conditionProperties)


data Entity = Entity { 
    entityAnnotations :: (Maybe (Annotations:|:[(Maybe Value)])),
    entityLocation :: (Maybe (Text:|:[(Maybe Value)])),
    entityRequired :: (Maybe (Bool:|:[(Maybe Value)])),
    entityType :: Text,
    entityDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Entity where
  parseJSON (Object v) = Entity <$> v .:? "annotations" <*> v .:? "location" <*> v .:? "required" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Entity where
  toJSON     (Entity {..}) = object ["annotations" .= entityAnnotations, "location" .= entityLocation, "required" .= entityRequired, "type" .= entityType, "description" .= entityDescription]
  toEncoding (Entity {..}) = pairs  ("annotations" .= entityAnnotations<>"location" .= entityLocation<>"required" .= entityRequired<>"type" .= entityType<>"description" .= entityDescription)


data Properties = Properties { 
    propertiesMaxAgeSeconds :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesDestination :: (Maybe (Resource:|:[(Maybe Value)])),
    propertiesEmail :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesKeySha256 :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesOrigin :: (Maybe (DefaultObjectAcl:|:[(Maybe Value)])),
    propertiesResourceUri :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesTemporaryHold :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesEtag :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesLockedTime :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesTimeStorageClassUpdated :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesResourceId :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesNextPageToken :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesState :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesMainPageSuffix :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesObjectNamePrefix :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesBucketPolicyOnly :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesRetentionExpirationTime :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesIfGenerationMatch :: (Maybe (Generation:|:[(Maybe Value)])),
    propertiesPayloadFormat :: (Maybe (PayloadFormat:|:[(Maybe Value)])),
    propertiesLocation :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesIamConfiguration :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesEnabled :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesSize :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesEventTypes :: (Maybe (DefaultObjectAcl:|:[(Maybe Value)])),
    propertiesKind :: (Maybe (Kind:|:[(Maybe Value)])),
    propertiesTimeDeleted :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesDone :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesNotFoundPage :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesCrc32c :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesUniformBucketLevelAccess :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesDomain :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesDaysSinceCustomTime :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesMembers :: (Maybe (Acl:|:[(Maybe Value)])),
    propertiesAge :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesExpiration :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesWebsite :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesToken :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesCustomerEncryption :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesProjectNumber :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesRule :: (Maybe (DefaultObjectAcl:|:[(Maybe Value)])),
    propertiesItems :: (Maybe (Items:|:[(Maybe Value)])),
    propertiesPrefixes :: (Maybe (DefaultObjectAcl:|:[(Maybe Value)])),
    propertiesBucket :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    propertiesAction :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesAddress :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesDefaultKmsKeyName :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesSecret :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesPayload :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesLifecycle :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesOwner :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesTopic :: (Maybe (Role:|:[(Maybe Value)])),
    propertiesRetentionPeriod :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesIsLive :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesParams :: (Maybe (CustomAttributes:|:[(Maybe Value)])),
    propertiesRetentionPolicy :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesZoneAffinity :: (Maybe (DefaultObjectAcl:|:[(Maybe Value)])),
    propertiesRole :: (Maybe (Role:|:[(Maybe Value)])),
    propertiesResponseHeader :: (Maybe (DefaultObjectAcl:|:[(Maybe Value)])),
    propertiesSelfLink :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesNumNewerVersions :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesMediaLink :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesComponentCount :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesName :: (Maybe (Name:|:[(Maybe Value)])),
    propertiesMethod :: (Maybe (DefaultObjectAcl:|:[(Maybe Value)])),
    propertiesCustomTimeBefore :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesEncryption :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesStorageClass :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesVersion :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesLogBucket :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesExpression :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesResource :: (Maybe (Resource:|:[(Maybe Value)])),
    propertiesMatchesStorageClass :: (Maybe (DefaultObjectAcl:|:[(Maybe Value)])),
    propertiesVersioning :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesBindings :: (Maybe (Acl:|:[(Maybe Value)])),
    propertiesContentEncoding :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    propertiesEventBasedHold :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesObjectPreconditions :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesTeam :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesMatchesPattern :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesObject :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    propertiesMetadata :: (Maybe (Metadata:|:[(Maybe Value)])),
    propertiesEmailAddress :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesCors :: (Maybe (DefaultObjectAcl:|:[(Maybe Value)])),
    propertiesTimeCreated :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesId :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesLabels :: (Maybe (CustomAttributes:|:[(Maybe Value)])),
    propertiesKmsKeyName :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    propertiesLocationType :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesRequesterPays :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesUpdated :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesServiceAccountEmail :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    propertiesPermissions :: (Maybe (Permissions:|:[(Maybe Value)])),
    propertiesDefaultObjectAcl :: (Maybe (DefaultObjectAcl:|:[(Maybe Value)])),
    propertiesProjectTeam :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesObjectSize :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesProjectId :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    propertiesTitle :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesEffectiveTime :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesType :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesIsLocked :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesEncryptionAlgorithm :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesCustomAttributes :: (Maybe (CustomAttributes:|:[(Maybe Value)])),
    propertiesContentLanguage :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesBilling :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesSourceObjects :: (Maybe (Acl:|:[(Maybe Value)])),
    propertiesCacheControl :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesCondition :: (Maybe (Condition:|:[(Maybe Value)])),
    propertiesMetageneration :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesTotalBytesRewritten :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesEntity :: (Maybe (Entity:|:[(Maybe Value)])),
    propertiesLogging :: (Maybe (Logging:|:[(Maybe Value)])),
    propertiesZoneSeparation :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesGeneration :: (Maybe (Generation:|:[(Maybe Value)])),
    propertiesAcl :: (Maybe (Acl:|:[(Maybe Value)])),
    propertiesCustomTime :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesEntityId :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesContentDisposition :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesMd5Hash :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesDescription :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesAccessId :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    propertiesDefaultEventBasedHold :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesContentType :: (Maybe (LogObjectPrefix:|:[(Maybe Value)])),
    propertiesCreatedBefore :: (Maybe (CreatedBefore:|:[(Maybe Value)])),
    propertiesRewriteToken :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    propertiesLogObjectPrefix :: (Maybe (LogObjectPrefix:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Properties where
  parseJSON (Object v) = Properties <$> v .:? "maxAgeSeconds" <*> v .:? "destination" <*> v .:? "email" <*> v .:? "keySha256" <*> v .:? "origin" <*> v .:? "resourceUri" <*> v .:? "temporaryHold" <*> v .:? "etag" <*> v .:? "lockedTime" <*> v .:? "timeStorageClassUpdated" <*> v .:? "resourceId" <*> v .:? "nextPageToken" <*> v .:? "state" <*> v .:? "mainPageSuffix" <*> v .:? "object_name_prefix" <*> v .:? "bucketPolicyOnly" <*> v .:? "retentionExpirationTime" <*> v .:? "ifGenerationMatch" <*> v .:? "payload_format" <*> v .:? "location" <*> v .:? "iamConfiguration" <*> v .:? "enabled" <*> v .:? "size" <*> v .:? "event_types" <*> v .:? "kind" <*> v .:? "timeDeleted" <*> v .:? "done" <*> v .:? "notFoundPage" <*> v .:? "crc32c" <*> v .:? "uniformBucketLevelAccess" <*> v .:? "domain" <*> v .:? "daysSinceCustomTime" <*> v .:? "members" <*> v .:? "age" <*> v .:? "expiration" <*> v .:? "website" <*> v .:? "token" <*> v .:? "customerEncryption" <*> v .:? "projectNumber" <*> v .:? "rule" <*> v .:? "items" <*> v .:? "prefixes" <*> v .:? "bucket" <*> v .:? "action" <*> v .:? "address" <*> v .:? "defaultKmsKeyName" <*> v .:? "secret" <*> v .:? "payload" <*> v .:? "lifecycle" <*> v .:? "owner" <*> v .:? "topic" <*> v .:? "retentionPeriod" <*> v .:? "isLive" <*> v .:? "params" <*> v .:? "retentionPolicy" <*> v .:? "zoneAffinity" <*> v .:? "role" <*> v .:? "responseHeader" <*> v .:? "selfLink" <*> v .:? "numNewerVersions" <*> v .:? "mediaLink" <*> v .:? "componentCount" <*> v .:? "name" <*> v .:? "method" <*> v .:? "customTimeBefore" <*> v .:? "encryption" <*> v .:? "storageClass" <*> v .:? "version" <*> v .:? "logBucket" <*> v .:? "expression" <*> v .:? "resource" <*> v .:? "matchesStorageClass" <*> v .:? "versioning" <*> v .:? "bindings" <*> v .:? "contentEncoding" <*> v .:? "eventBasedHold" <*> v .:? "objectPreconditions" <*> v .:? "team" <*> v .:? "matchesPattern" <*> v .:? "object" <*> v .:? "metadata" <*> v .:? "email_address" <*> v .:? "cors" <*> v .:? "timeCreated" <*> v .:? "id" <*> v .:? "labels" <*> v .:? "kmsKeyName" <*> v .:? "locationType" <*> v .:? "requesterPays" <*> v .:? "updated" <*> v .:? "serviceAccountEmail" <*> v .:? "permissions" <*> v .:? "defaultObjectAcl" <*> v .:? "projectTeam" <*> v .:? "objectSize" <*> v .:? "projectId" <*> v .:? "title" <*> v .:? "effectiveTime" <*> v .:? "type" <*> v .:? "isLocked" <*> v .:? "encryptionAlgorithm" <*> v .:? "custom_attributes" <*> v .:? "contentLanguage" <*> v .:? "billing" <*> v .:? "sourceObjects" <*> v .:? "cacheControl" <*> v .:? "condition" <*> v .:? "metageneration" <*> v .:? "totalBytesRewritten" <*> v .:? "entity" <*> v .:? "logging" <*> v .:? "zoneSeparation" <*> v .:? "generation" <*> v .:? "acl" <*> v .:? "customTime" <*> v .:? "entityId" <*> v .:? "contentDisposition" <*> v .:? "md5Hash" <*> v .:? "description" <*> v .:? "accessId" <*> v .:? "defaultEventBasedHold" <*> v .:? "contentType" <*> v .:? "createdBefore" <*> v .:? "rewriteToken" <*> v .:? "logObjectPrefix"
  parseJSON _          = mzero


instance ToJSON Properties where
  toJSON     (Properties {..}) = object ["maxAgeSeconds" .= propertiesMaxAgeSeconds, "destination" .= propertiesDestination, "email" .= propertiesEmail, "keySha256" .= propertiesKeySha256, "origin" .= propertiesOrigin, "resourceUri" .= propertiesResourceUri, "temporaryHold" .= propertiesTemporaryHold, "etag" .= propertiesEtag, "lockedTime" .= propertiesLockedTime, "timeStorageClassUpdated" .= propertiesTimeStorageClassUpdated, "resourceId" .= propertiesResourceId, "nextPageToken" .= propertiesNextPageToken, "state" .= propertiesState, "mainPageSuffix" .= propertiesMainPageSuffix, "object_name_prefix" .= propertiesObjectNamePrefix, "bucketPolicyOnly" .= propertiesBucketPolicyOnly, "retentionExpirationTime" .= propertiesRetentionExpirationTime, "ifGenerationMatch" .= propertiesIfGenerationMatch, "payload_format" .= propertiesPayloadFormat, "location" .= propertiesLocation, "iamConfiguration" .= propertiesIamConfiguration, "enabled" .= propertiesEnabled, "size" .= propertiesSize, "event_types" .= propertiesEventTypes, "kind" .= propertiesKind, "timeDeleted" .= propertiesTimeDeleted, "done" .= propertiesDone, "notFoundPage" .= propertiesNotFoundPage, "crc32c" .= propertiesCrc32c, "uniformBucketLevelAccess" .= propertiesUniformBucketLevelAccess, "domain" .= propertiesDomain, "daysSinceCustomTime" .= propertiesDaysSinceCustomTime, "members" .= propertiesMembers, "age" .= propertiesAge, "expiration" .= propertiesExpiration, "website" .= propertiesWebsite, "token" .= propertiesToken, "customerEncryption" .= propertiesCustomerEncryption, "projectNumber" .= propertiesProjectNumber, "rule" .= propertiesRule, "items" .= propertiesItems, "prefixes" .= propertiesPrefixes, "bucket" .= propertiesBucket, "action" .= propertiesAction, "address" .= propertiesAddress, "defaultKmsKeyName" .= propertiesDefaultKmsKeyName, "secret" .= propertiesSecret, "payload" .= propertiesPayload, "lifecycle" .= propertiesLifecycle, "owner" .= propertiesOwner, "topic" .= propertiesTopic, "retentionPeriod" .= propertiesRetentionPeriod, "isLive" .= propertiesIsLive, "params" .= propertiesParams, "retentionPolicy" .= propertiesRetentionPolicy, "zoneAffinity" .= propertiesZoneAffinity, "role" .= propertiesRole, "responseHeader" .= propertiesResponseHeader, "selfLink" .= propertiesSelfLink, "numNewerVersions" .= propertiesNumNewerVersions, "mediaLink" .= propertiesMediaLink, "componentCount" .= propertiesComponentCount, "name" .= propertiesName, "method" .= propertiesMethod, "customTimeBefore" .= propertiesCustomTimeBefore, "encryption" .= propertiesEncryption, "storageClass" .= propertiesStorageClass, "version" .= propertiesVersion, "logBucket" .= propertiesLogBucket, "expression" .= propertiesExpression, "resource" .= propertiesResource, "matchesStorageClass" .= propertiesMatchesStorageClass, "versioning" .= propertiesVersioning, "bindings" .= propertiesBindings, "contentEncoding" .= propertiesContentEncoding, "eventBasedHold" .= propertiesEventBasedHold, "objectPreconditions" .= propertiesObjectPreconditions, "team" .= propertiesTeam, "matchesPattern" .= propertiesMatchesPattern, "object" .= propertiesObject, "metadata" .= propertiesMetadata, "email_address" .= propertiesEmailAddress, "cors" .= propertiesCors, "timeCreated" .= propertiesTimeCreated, "id" .= propertiesId, "labels" .= propertiesLabels, "kmsKeyName" .= propertiesKmsKeyName, "locationType" .= propertiesLocationType, "requesterPays" .= propertiesRequesterPays, "updated" .= propertiesUpdated, "serviceAccountEmail" .= propertiesServiceAccountEmail, "permissions" .= propertiesPermissions, "defaultObjectAcl" .= propertiesDefaultObjectAcl, "projectTeam" .= propertiesProjectTeam, "objectSize" .= propertiesObjectSize, "projectId" .= propertiesProjectId, "title" .= propertiesTitle, "effectiveTime" .= propertiesEffectiveTime, "type" .= propertiesType, "isLocked" .= propertiesIsLocked, "encryptionAlgorithm" .= propertiesEncryptionAlgorithm, "custom_attributes" .= propertiesCustomAttributes, "contentLanguage" .= propertiesContentLanguage, "billing" .= propertiesBilling, "sourceObjects" .= propertiesSourceObjects, "cacheControl" .= propertiesCacheControl, "condition" .= propertiesCondition, "metageneration" .= propertiesMetageneration, "totalBytesRewritten" .= propertiesTotalBytesRewritten, "entity" .= propertiesEntity, "logging" .= propertiesLogging, "zoneSeparation" .= propertiesZoneSeparation, "generation" .= propertiesGeneration, "acl" .= propertiesAcl, "customTime" .= propertiesCustomTime, "entityId" .= propertiesEntityId, "contentDisposition" .= propertiesContentDisposition, "md5Hash" .= propertiesMd5Hash, "description" .= propertiesDescription, "accessId" .= propertiesAccessId, "defaultEventBasedHold" .= propertiesDefaultEventBasedHold, "contentType" .= propertiesContentType, "createdBefore" .= propertiesCreatedBefore, "rewriteToken" .= propertiesRewriteToken, "logObjectPrefix" .= propertiesLogObjectPrefix]
  toEncoding (Properties {..}) = pairs  ("maxAgeSeconds" .= propertiesMaxAgeSeconds<>"destination" .= propertiesDestination<>"email" .= propertiesEmail<>"keySha256" .= propertiesKeySha256<>"origin" .= propertiesOrigin<>"resourceUri" .= propertiesResourceUri<>"temporaryHold" .= propertiesTemporaryHold<>"etag" .= propertiesEtag<>"lockedTime" .= propertiesLockedTime<>"timeStorageClassUpdated" .= propertiesTimeStorageClassUpdated<>"resourceId" .= propertiesResourceId<>"nextPageToken" .= propertiesNextPageToken<>"state" .= propertiesState<>"mainPageSuffix" .= propertiesMainPageSuffix<>"object_name_prefix" .= propertiesObjectNamePrefix<>"bucketPolicyOnly" .= propertiesBucketPolicyOnly<>"retentionExpirationTime" .= propertiesRetentionExpirationTime<>"ifGenerationMatch" .= propertiesIfGenerationMatch<>"payload_format" .= propertiesPayloadFormat<>"location" .= propertiesLocation<>"iamConfiguration" .= propertiesIamConfiguration<>"enabled" .= propertiesEnabled<>"size" .= propertiesSize<>"event_types" .= propertiesEventTypes<>"kind" .= propertiesKind<>"timeDeleted" .= propertiesTimeDeleted<>"done" .= propertiesDone<>"notFoundPage" .= propertiesNotFoundPage<>"crc32c" .= propertiesCrc32c<>"uniformBucketLevelAccess" .= propertiesUniformBucketLevelAccess<>"domain" .= propertiesDomain<>"daysSinceCustomTime" .= propertiesDaysSinceCustomTime<>"members" .= propertiesMembers<>"age" .= propertiesAge<>"expiration" .= propertiesExpiration<>"website" .= propertiesWebsite<>"token" .= propertiesToken<>"customerEncryption" .= propertiesCustomerEncryption<>"projectNumber" .= propertiesProjectNumber<>"rule" .= propertiesRule<>"items" .= propertiesItems<>"prefixes" .= propertiesPrefixes<>"bucket" .= propertiesBucket<>"action" .= propertiesAction<>"address" .= propertiesAddress<>"defaultKmsKeyName" .= propertiesDefaultKmsKeyName<>"secret" .= propertiesSecret<>"payload" .= propertiesPayload<>"lifecycle" .= propertiesLifecycle<>"owner" .= propertiesOwner<>"topic" .= propertiesTopic<>"retentionPeriod" .= propertiesRetentionPeriod<>"isLive" .= propertiesIsLive<>"params" .= propertiesParams<>"retentionPolicy" .= propertiesRetentionPolicy<>"zoneAffinity" .= propertiesZoneAffinity<>"role" .= propertiesRole<>"responseHeader" .= propertiesResponseHeader<>"selfLink" .= propertiesSelfLink<>"numNewerVersions" .= propertiesNumNewerVersions<>"mediaLink" .= propertiesMediaLink<>"componentCount" .= propertiesComponentCount<>"name" .= propertiesName<>"method" .= propertiesMethod<>"customTimeBefore" .= propertiesCustomTimeBefore<>"encryption" .= propertiesEncryption<>"storageClass" .= propertiesStorageClass<>"version" .= propertiesVersion<>"logBucket" .= propertiesLogBucket<>"expression" .= propertiesExpression<>"resource" .= propertiesResource<>"matchesStorageClass" .= propertiesMatchesStorageClass<>"versioning" .= propertiesVersioning<>"bindings" .= propertiesBindings<>"contentEncoding" .= propertiesContentEncoding<>"eventBasedHold" .= propertiesEventBasedHold<>"objectPreconditions" .= propertiesObjectPreconditions<>"team" .= propertiesTeam<>"matchesPattern" .= propertiesMatchesPattern<>"object" .= propertiesObject<>"metadata" .= propertiesMetadata<>"email_address" .= propertiesEmailAddress<>"cors" .= propertiesCors<>"timeCreated" .= propertiesTimeCreated<>"id" .= propertiesId<>"labels" .= propertiesLabels<>"kmsKeyName" .= propertiesKmsKeyName<>"locationType" .= propertiesLocationType<>"requesterPays" .= propertiesRequesterPays<>"updated" .= propertiesUpdated<>"serviceAccountEmail" .= propertiesServiceAccountEmail<>"permissions" .= propertiesPermissions<>"defaultObjectAcl" .= propertiesDefaultObjectAcl<>"projectTeam" .= propertiesProjectTeam<>"objectSize" .= propertiesObjectSize<>"projectId" .= propertiesProjectId<>"title" .= propertiesTitle<>"effectiveTime" .= propertiesEffectiveTime<>"type" .= propertiesType<>"isLocked" .= propertiesIsLocked<>"encryptionAlgorithm" .= propertiesEncryptionAlgorithm<>"custom_attributes" .= propertiesCustomAttributes<>"contentLanguage" .= propertiesContentLanguage<>"billing" .= propertiesBilling<>"sourceObjects" .= propertiesSourceObjects<>"cacheControl" .= propertiesCacheControl<>"condition" .= propertiesCondition<>"metageneration" .= propertiesMetageneration<>"totalBytesRewritten" .= propertiesTotalBytesRewritten<>"entity" .= propertiesEntity<>"logging" .= propertiesLogging<>"zoneSeparation" .= propertiesZoneSeparation<>"generation" .= propertiesGeneration<>"acl" .= propertiesAcl<>"customTime" .= propertiesCustomTime<>"entityId" .= propertiesEntityId<>"contentDisposition" .= propertiesContentDisposition<>"md5Hash" .= propertiesMd5Hash<>"description" .= propertiesDescription<>"accessId" .= propertiesAccessId<>"defaultEventBasedHold" .= propertiesDefaultEventBasedHold<>"contentType" .= propertiesContentType<>"createdBefore" .= propertiesCreatedBefore<>"rewriteToken" .= propertiesRewriteToken<>"logObjectPrefix" .= propertiesLogObjectPrefix)


data RewriteResponse = RewriteResponse { 
    rewriteResponseId :: Text,
    rewriteResponseType :: Text,
    rewriteResponseDescription :: Text,
    rewriteResponseProperties :: Properties:|:[(Maybe Value)]
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON RewriteResponse where
  parseJSON (Object v) = RewriteResponse <$> v .:  "id" <*> v .:  "type" <*> v .:  "description" <*> v .:  "properties"
  parseJSON _          = mzero


instance ToJSON RewriteResponse where
  toJSON     (RewriteResponse {..}) = object ["id" .= rewriteResponseId, "type" .= rewriteResponseType, "description" .= rewriteResponseDescription, "properties" .= rewriteResponseProperties]
  toEncoding (RewriteResponse {..}) = pairs  ("id" .= rewriteResponseId<>"type" .= rewriteResponseType<>"description" .= rewriteResponseDescription<>"properties" .= rewriteResponseProperties)


data Schemas = Schemas { 
    schemasExpr :: RewriteResponse,
    schemasNotification :: RewriteResponse,
    schemasBuckets :: RewriteResponse,
    schemasHmacKeyMetadata :: RewriteResponse,
    schemasChannel :: RewriteResponse,
    schemasBucket :: RewriteResponse,
    schemasHmacKeysMetadata :: RewriteResponse,
    schemasBucketAccessControls :: RewriteResponse,
    schemasObjects :: RewriteResponse,
    schemasComposeRequest :: RewriteResponse,
    schemasServiceAccount :: RewriteResponse,
    schemasBucketAccessControl :: RewriteResponse,
    schemasObjectAccessControls :: RewriteResponse,
    schemasObject :: RewriteResponse,
    schemasTestIamPermissionsResponse :: RewriteResponse,
    schemasPolicy :: RewriteResponse,
    schemasHmacKey :: RewriteResponse,
    schemasObjectAccessControl :: RewriteResponse,
    schemasNotifications :: RewriteResponse,
    schemasRewriteResponse :: RewriteResponse
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Schemas where
  parseJSON (Object v) = Schemas <$> v .:  "Expr" <*> v .:  "Notification" <*> v .:  "Buckets" <*> v .:  "HmacKeyMetadata" <*> v .:  "Channel" <*> v .:  "Bucket" <*> v .:  "HmacKeysMetadata" <*> v .:  "BucketAccessControls" <*> v .:  "Objects" <*> v .:  "ComposeRequest" <*> v .:  "ServiceAccount" <*> v .:  "BucketAccessControl" <*> v .:  "ObjectAccessControls" <*> v .:  "Object" <*> v .:  "TestIamPermissionsResponse" <*> v .:  "Policy" <*> v .:  "HmacKey" <*> v .:  "ObjectAccessControl" <*> v .:  "Notifications" <*> v .:  "RewriteResponse"
  parseJSON _          = mzero


instance ToJSON Schemas where
  toJSON     (Schemas {..}) = object ["Expr" .= schemasExpr, "Notification" .= schemasNotification, "Buckets" .= schemasBuckets, "HmacKeyMetadata" .= schemasHmacKeyMetadata, "Channel" .= schemasChannel, "Bucket" .= schemasBucket, "HmacKeysMetadata" .= schemasHmacKeysMetadata, "BucketAccessControls" .= schemasBucketAccessControls, "Objects" .= schemasObjects, "ComposeRequest" .= schemasComposeRequest, "ServiceAccount" .= schemasServiceAccount, "BucketAccessControl" .= schemasBucketAccessControl, "ObjectAccessControls" .= schemasObjectAccessControls, "Object" .= schemasObject, "TestIamPermissionsResponse" .= schemasTestIamPermissionsResponse, "Policy" .= schemasPolicy, "HmacKey" .= schemasHmacKey, "ObjectAccessControl" .= schemasObjectAccessControl, "Notifications" .= schemasNotifications, "RewriteResponse" .= schemasRewriteResponse]
  toEncoding (Schemas {..}) = pairs  ("Expr" .= schemasExpr<>"Notification" .= schemasNotification<>"Buckets" .= schemasBuckets<>"HmacKeyMetadata" .= schemasHmacKeyMetadata<>"Channel" .= schemasChannel<>"Bucket" .= schemasBucket<>"HmacKeysMetadata" .= schemasHmacKeysMetadata<>"BucketAccessControls" .= schemasBucketAccessControls<>"Objects" .= schemasObjects<>"ComposeRequest" .= schemasComposeRequest<>"ServiceAccount" .= schemasServiceAccount<>"BucketAccessControl" .= schemasBucketAccessControl<>"ObjectAccessControls" .= schemasObjectAccessControls<>"Object" .= schemasObject<>"TestIamPermissionsResponse" .= schemasTestIamPermissionsResponse<>"Policy" .= schemasPolicy<>"HmacKey" .= schemasHmacKey<>"ObjectAccessControl" .= schemasObjectAccessControl<>"Notifications" .= schemasNotifications<>"RewriteResponse" .= schemasRewriteResponse)


data HttpsWwwGoogleapisComAuthDevstorageFullControl = HttpsWwwGoogleapisComAuthDevstorageFullControl { 
    httpsWwwGoogleapisComAuthDevstorageFullControlDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON HttpsWwwGoogleapisComAuthDevstorageFullControl where
  parseJSON (Object v) = HttpsWwwGoogleapisComAuthDevstorageFullControl <$> v .:  "description"
  parseJSON _          = mzero


instance ToJSON HttpsWwwGoogleapisComAuthDevstorageFullControl where
  toJSON     (HttpsWwwGoogleapisComAuthDevstorageFullControl {..}) = object ["description" .= httpsWwwGoogleapisComAuthDevstorageFullControlDescription]
  toEncoding (HttpsWwwGoogleapisComAuthDevstorageFullControl {..}) = pairs  ("description" .= httpsWwwGoogleapisComAuthDevstorageFullControlDescription)


data Scopes = Scopes { 
    scopesHttpsWwwGoogleapisComAuthCloudPlatformReadOnly :: HttpsWwwGoogleapisComAuthDevstorageFullControl,
    scopesHttpsWwwGoogleapisComAuthCloudPlatform :: HttpsWwwGoogleapisComAuthDevstorageFullControl,
    scopesHttpsWwwGoogleapisComAuthDevstorageReadOnly :: HttpsWwwGoogleapisComAuthDevstorageFullControl,
    scopesHttpsWwwGoogleapisComAuthDevstorageReadWrite :: HttpsWwwGoogleapisComAuthDevstorageFullControl,
    scopesHttpsWwwGoogleapisComAuthDevstorageFullControl :: HttpsWwwGoogleapisComAuthDevstorageFullControl
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Scopes where
  parseJSON (Object v) = Scopes <$> v .:  "https://www.googleapis.com/auth/cloud-platform.read-only" <*> v .:  "https://www.googleapis.com/auth/cloud-platform" <*> v .:  "https://www.googleapis.com/auth/devstorage.read_only" <*> v .:  "https://www.googleapis.com/auth/devstorage.read_write" <*> v .:  "https://www.googleapis.com/auth/devstorage.full_control"
  parseJSON _          = mzero


instance ToJSON Scopes where
  toJSON     (Scopes {..}) = object ["https://www.googleapis.com/auth/cloud-platform.read-only" .= scopesHttpsWwwGoogleapisComAuthCloudPlatformReadOnly, "https://www.googleapis.com/auth/cloud-platform" .= scopesHttpsWwwGoogleapisComAuthCloudPlatform, "https://www.googleapis.com/auth/devstorage.read_only" .= scopesHttpsWwwGoogleapisComAuthDevstorageReadOnly, "https://www.googleapis.com/auth/devstorage.read_write" .= scopesHttpsWwwGoogleapisComAuthDevstorageReadWrite, "https://www.googleapis.com/auth/devstorage.full_control" .= scopesHttpsWwwGoogleapisComAuthDevstorageFullControl]
  toEncoding (Scopes {..}) = pairs  ("https://www.googleapis.com/auth/cloud-platform.read-only" .= scopesHttpsWwwGoogleapisComAuthCloudPlatformReadOnly<>"https://www.googleapis.com/auth/cloud-platform" .= scopesHttpsWwwGoogleapisComAuthCloudPlatform<>"https://www.googleapis.com/auth/devstorage.read_only" .= scopesHttpsWwwGoogleapisComAuthDevstorageReadOnly<>"https://www.googleapis.com/auth/devstorage.read_write" .= scopesHttpsWwwGoogleapisComAuthDevstorageReadWrite<>"https://www.googleapis.com/auth/devstorage.full_control" .= scopesHttpsWwwGoogleapisComAuthDevstorageFullControl)


data Oauth2 = Oauth2 { 
    oauth2Scopes :: Scopes
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Oauth2 where
  parseJSON (Object v) = Oauth2 <$> v .:  "scopes"
  parseJSON _          = mzero


instance ToJSON Oauth2 where
  toJSON     (Oauth2 {..}) = object ["scopes" .= oauth2Scopes]
  toEncoding (Oauth2 {..}) = pairs  ("scopes" .= oauth2Scopes)


data Auth = Auth { 
    authOauth2 :: Oauth2
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Auth where
  parseJSON (Object v) = Auth <$> v .:  "oauth2"
  parseJSON _          = mzero


instance ToJSON Auth where
  toJSON     (Auth {..}) = object ["oauth2" .= authOauth2]
  toEncoding (Auth {..}) = pairs  ("oauth2" .= authOauth2)


data Icons = Icons { 
    iconsX16 :: Text,
    iconsX32 :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Icons where
  parseJSON (Object v) = Icons <$> v .:  "x16" <*> v .:  "x32"
  parseJSON _          = mzero


instance ToJSON Icons where
  toJSON     (Icons {..}) = object ["x16" .= iconsX16, "x32" .= iconsX32]
  toEncoding (Icons {..}) = pairs  ("x16" .= iconsX16<>"x32" .= iconsX32)


data Resumable = Resumable { 
    resumablePath :: Text,
    resumableMultipart :: Bool
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Resumable where
  parseJSON (Object v) = Resumable <$> v .:  "path" <*> v .:  "multipart"
  parseJSON _          = mzero


instance ToJSON Resumable where
  toJSON     (Resumable {..}) = object ["path" .= resumablePath, "multipart" .= resumableMultipart]
  toEncoding (Resumable {..}) = pairs  ("path" .= resumablePath<>"multipart" .= resumableMultipart)


data Protocols = Protocols { 
    protocolsSimple :: Resumable,
    protocolsResumable :: Resumable
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Protocols where
  parseJSON (Object v) = Protocols <$> v .:  "simple" <*> v .:  "resumable"
  parseJSON _          = mzero


instance ToJSON Protocols where
  toJSON     (Protocols {..}) = object ["simple" .= protocolsSimple, "resumable" .= protocolsResumable]
  toEncoding (Protocols {..}) = pairs  ("simple" .= protocolsSimple<>"resumable" .= protocolsResumable)


data MediaUpload = MediaUpload { 
    mediaUploadProtocols :: Protocols,
    mediaUploadAccept :: [Text]
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON MediaUpload where
  parseJSON (Object v) = MediaUpload <$> v .:  "protocols" <*> v .:  "accept"
  parseJSON _          = mzero


instance ToJSON MediaUpload where
  toJSON     (MediaUpload {..}) = object ["protocols" .= mediaUploadProtocols, "accept" .= mediaUploadAccept]
  toEncoding (MediaUpload {..}) = pairs  ("protocols" .= mediaUploadProtocols<>"accept" .= mediaUploadAccept)


data Response = Response { 
    responseRef :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Response where
  parseJSON (Object v) = Response <$> v .:  "$ref"
  parseJSON _          = mzero


instance ToJSON Response where
  toJSON     (Response {..}) = object ["$ref" .= responseRef]
  toEncoding (Response {..}) = pairs  ("$ref" .= responseRef)


data Projection = Projection { 
    projectionLocation :: Text,
    projectionType :: Text,
    projectionEnum :: [Text],
    projectionEnumDescriptions :: [Text],
    projectionDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Projection where
  parseJSON (Object v) = Projection <$> v .:  "location" <*> v .:  "type" <*> v .:  "enum" <*> v .:  "enumDescriptions" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Projection where
  toJSON     (Projection {..}) = object ["location" .= projectionLocation, "type" .= projectionType, "enum" .= projectionEnum, "enumDescriptions" .= projectionEnumDescriptions, "description" .= projectionDescription]
  toEncoding (Projection {..}) = pairs  ("location" .= projectionLocation<>"type" .= projectionType<>"enum" .= projectionEnum<>"enumDescriptions" .= projectionEnumDescriptions<>"description" .= projectionDescription)


data IfMetagenerationMatch = IfMetagenerationMatch { 
    ifMetagenerationMatchLocation :: Text,
    ifMetagenerationMatchFormat :: Text,
    ifMetagenerationMatchRequired :: (Maybe (Bool:|:[(Maybe Value)])),
    ifMetagenerationMatchType :: Text,
    ifMetagenerationMatchDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON IfMetagenerationMatch where
  parseJSON (Object v) = IfMetagenerationMatch <$> v .:  "location" <*> v .:  "format" <*> v .:? "required" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON IfMetagenerationMatch where
  toJSON     (IfMetagenerationMatch {..}) = object ["location" .= ifMetagenerationMatchLocation, "format" .= ifMetagenerationMatchFormat, "required" .= ifMetagenerationMatchRequired, "type" .= ifMetagenerationMatchType, "description" .= ifMetagenerationMatchDescription]
  toEncoding (IfMetagenerationMatch {..}) = pairs  ("location" .= ifMetagenerationMatchLocation<>"format" .= ifMetagenerationMatchFormat<>"required" .= ifMetagenerationMatchRequired<>"type" .= ifMetagenerationMatchType<>"description" .= ifMetagenerationMatchDescription)


data PrettyPrint = PrettyPrint { 
    prettyPrintLocation :: Text,
    prettyPrintDefault :: Text,
    prettyPrintType :: Text,
    prettyPrintDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON PrettyPrint where
  parseJSON (Object v) = PrettyPrint <$> v .:  "location" <*> v .:  "default" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON PrettyPrint where
  toJSON     (PrettyPrint {..}) = object ["location" .= prettyPrintLocation, "default" .= prettyPrintDefault, "type" .= prettyPrintType, "description" .= prettyPrintDescription]
  toEncoding (PrettyPrint {..}) = pairs  ("location" .= prettyPrintLocation<>"default" .= prettyPrintDefault<>"type" .= prettyPrintType<>"description" .= prettyPrintDescription)


data OptionsRequestedPolicyVersion = OptionsRequestedPolicyVersion { 
    optionsRequestedPolicyVersionLocation :: Text,
    optionsRequestedPolicyVersionFormat :: Text,
    optionsRequestedPolicyVersionMinimum :: Text,
    optionsRequestedPolicyVersionType :: Text,
    optionsRequestedPolicyVersionDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON OptionsRequestedPolicyVersion where
  parseJSON (Object v) = OptionsRequestedPolicyVersion <$> v .:  "location" <*> v .:  "format" <*> v .:  "minimum" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON OptionsRequestedPolicyVersion where
  toJSON     (OptionsRequestedPolicyVersion {..}) = object ["location" .= optionsRequestedPolicyVersionLocation, "format" .= optionsRequestedPolicyVersionFormat, "minimum" .= optionsRequestedPolicyVersionMinimum, "type" .= optionsRequestedPolicyVersionType, "description" .= optionsRequestedPolicyVersionDescription]
  toEncoding (OptionsRequestedPolicyVersion {..}) = pairs  ("location" .= optionsRequestedPolicyVersionLocation<>"format" .= optionsRequestedPolicyVersionFormat<>"minimum" .= optionsRequestedPolicyVersionMinimum<>"type" .= optionsRequestedPolicyVersionType<>"description" .= optionsRequestedPolicyVersionDescription)


data MaxResults = MaxResults { 
    maxResultsLocation :: Text,
    maxResultsDefault :: Text,
    maxResultsFormat :: Text,
    maxResultsMinimum :: Text,
    maxResultsType :: Text,
    maxResultsDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON MaxResults where
  parseJSON (Object v) = MaxResults <$> v .:  "location" <*> v .:  "default" <*> v .:  "format" <*> v .:  "minimum" <*> v .:  "type" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON MaxResults where
  toJSON     (MaxResults {..}) = object ["location" .= maxResultsLocation, "default" .= maxResultsDefault, "format" .= maxResultsFormat, "minimum" .= maxResultsMinimum, "type" .= maxResultsType, "description" .= maxResultsDescription]
  toEncoding (MaxResults {..}) = pairs  ("location" .= maxResultsLocation<>"default" .= maxResultsDefault<>"format" .= maxResultsFormat<>"minimum" .= maxResultsMinimum<>"type" .= maxResultsType<>"description" .= maxResultsDescription)


data Alt = Alt { 
    altLocation :: Text,
    altDefault :: Text,
    altType :: Text,
    altEnum :: [Text],
    altEnumDescriptions :: [Text],
    altDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Alt where
  parseJSON (Object v) = Alt <$> v .:  "location" <*> v .:  "default" <*> v .:  "type" <*> v .:  "enum" <*> v .:  "enumDescriptions" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Alt where
  toJSON     (Alt {..}) = object ["location" .= altLocation, "default" .= altDefault, "type" .= altType, "enum" .= altEnum, "enumDescriptions" .= altEnumDescriptions, "description" .= altDescription]
  toEncoding (Alt {..}) = pairs  ("location" .= altLocation<>"default" .= altDefault<>"type" .= altType<>"enum" .= altEnum<>"enumDescriptions" .= altEnumDescriptions<>"description" .= altDescription)


data Parameters = Parameters { 
    parametersDestinationPredefinedAcl :: (Maybe (Projection:|:[(Maybe Value)])),
    parametersQuotaUser :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersIfSourceGenerationMatch :: (Maybe (Generation:|:[(Maybe Value)])),
    parametersIfMetagenerationMatch :: (Maybe (IfMetagenerationMatch:|:[(Maybe Value)])),
    parametersIfGenerationNotMatch :: (Maybe (Generation:|:[(Maybe Value)])),
    parametersPrettyPrint :: (Maybe (PrettyPrint:|:[(Maybe Value)])),
    parametersIfSourceMetagenerationNotMatch :: (Maybe (Generation:|:[(Maybe Value)])),
    parametersIfSourceMetagenerationMatch :: (Maybe (Generation:|:[(Maybe Value)])),
    parametersShowDeletedKeys :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersIfGenerationMatch :: (Maybe (Generation:|:[(Maybe Value)])),
    parametersStartOffset :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersProject :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    parametersNotification :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    parametersPrefix :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersUserIp :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersPredefinedAcl :: (Maybe (Projection:|:[(Maybe Value)])),
    parametersSourceObject :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    parametersMaxBytesRewrittenPerCall :: (Maybe (Generation:|:[(Maybe Value)])),
    parametersSourceBucket :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    parametersBucket :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    parametersPredefinedDefaultObjectAcl :: (Maybe (Projection:|:[(Maybe Value)])),
    parametersVersions :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersUserProject :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersKey :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersName :: (Maybe (Name:|:[(Maybe Value)])),
    parametersDestinationBucket :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    parametersOptionsRequestedPolicyVersion :: (Maybe (OptionsRequestedPolicyVersion:|:[(Maybe Value)])),
    parametersIfMetagenerationNotMatch :: (Maybe (Generation:|:[(Maybe Value)])),
    parametersIfSourceGenerationNotMatch :: (Maybe (Generation:|:[(Maybe Value)])),
    parametersContentEncoding :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersEndOffset :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersObject :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    parametersIncludeTrailingDelimiter :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersKmsKeyName :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersProjection :: (Maybe (Projection:|:[(Maybe Value)])),
    parametersServiceAccountEmail :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    parametersPermissions :: (Maybe (Permissions:|:[(Maybe Value)])),
    parametersProvisionalUserProject :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersPageToken :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersProjectId :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    parametersOauthToken :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersDelimiter :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersSourceGeneration :: (Maybe (Generation:|:[(Maybe Value)])),
    parametersEntity :: (Maybe (Entity:|:[(Maybe Value)])),
    parametersGeneration :: (Maybe (Generation:|:[(Maybe Value)])),
    parametersMaxResults :: (Maybe (MaxResults:|:[(Maybe Value)])),
    parametersAccessId :: (Maybe (DestinationObject:|:[(Maybe Value)])),
    parametersDestinationKmsKeyName :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersFields :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersAlt :: (Maybe (Alt:|:[(Maybe Value)])),
    parametersRewriteToken :: (Maybe (RewriteToken:|:[(Maybe Value)])),
    parametersDestinationObject :: (Maybe (DestinationObject:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Parameters where
  parseJSON (Object v) = Parameters <$> v .:? "destinationPredefinedAcl" <*> v .:? "quotaUser" <*> v .:? "ifSourceGenerationMatch" <*> v .:? "ifMetagenerationMatch" <*> v .:? "ifGenerationNotMatch" <*> v .:? "prettyPrint" <*> v .:? "ifSourceMetagenerationNotMatch" <*> v .:? "ifSourceMetagenerationMatch" <*> v .:? "showDeletedKeys" <*> v .:? "ifGenerationMatch" <*> v .:? "startOffset" <*> v .:? "project" <*> v .:? "notification" <*> v .:? "prefix" <*> v .:? "userIp" <*> v .:? "predefinedAcl" <*> v .:? "sourceObject" <*> v .:? "maxBytesRewrittenPerCall" <*> v .:? "sourceBucket" <*> v .:? "bucket" <*> v .:? "predefinedDefaultObjectAcl" <*> v .:? "versions" <*> v .:? "userProject" <*> v .:? "key" <*> v .:? "name" <*> v .:? "destinationBucket" <*> v .:? "optionsRequestedPolicyVersion" <*> v .:? "ifMetagenerationNotMatch" <*> v .:? "ifSourceGenerationNotMatch" <*> v .:? "contentEncoding" <*> v .:? "endOffset" <*> v .:? "object" <*> v .:? "includeTrailingDelimiter" <*> v .:? "kmsKeyName" <*> v .:? "projection" <*> v .:? "serviceAccountEmail" <*> v .:? "permissions" <*> v .:? "provisionalUserProject" <*> v .:? "pageToken" <*> v .:? "projectId" <*> v .:? "oauth_token" <*> v .:? "delimiter" <*> v .:? "sourceGeneration" <*> v .:? "entity" <*> v .:? "generation" <*> v .:? "maxResults" <*> v .:? "accessId" <*> v .:? "destinationKmsKeyName" <*> v .:? "fields" <*> v .:? "alt" <*> v .:? "rewriteToken" <*> v .:? "destinationObject"
  parseJSON _          = mzero


instance ToJSON Parameters where
  toJSON     (Parameters {..}) = object ["destinationPredefinedAcl" .= parametersDestinationPredefinedAcl, "quotaUser" .= parametersQuotaUser, "ifSourceGenerationMatch" .= parametersIfSourceGenerationMatch, "ifMetagenerationMatch" .= parametersIfMetagenerationMatch, "ifGenerationNotMatch" .= parametersIfGenerationNotMatch, "prettyPrint" .= parametersPrettyPrint, "ifSourceMetagenerationNotMatch" .= parametersIfSourceMetagenerationNotMatch, "ifSourceMetagenerationMatch" .= parametersIfSourceMetagenerationMatch, "showDeletedKeys" .= parametersShowDeletedKeys, "ifGenerationMatch" .= parametersIfGenerationMatch, "startOffset" .= parametersStartOffset, "project" .= parametersProject, "notification" .= parametersNotification, "prefix" .= parametersPrefix, "userIp" .= parametersUserIp, "predefinedAcl" .= parametersPredefinedAcl, "sourceObject" .= parametersSourceObject, "maxBytesRewrittenPerCall" .= parametersMaxBytesRewrittenPerCall, "sourceBucket" .= parametersSourceBucket, "bucket" .= parametersBucket, "predefinedDefaultObjectAcl" .= parametersPredefinedDefaultObjectAcl, "versions" .= parametersVersions, "userProject" .= parametersUserProject, "key" .= parametersKey, "name" .= parametersName, "destinationBucket" .= parametersDestinationBucket, "optionsRequestedPolicyVersion" .= parametersOptionsRequestedPolicyVersion, "ifMetagenerationNotMatch" .= parametersIfMetagenerationNotMatch, "ifSourceGenerationNotMatch" .= parametersIfSourceGenerationNotMatch, "contentEncoding" .= parametersContentEncoding, "endOffset" .= parametersEndOffset, "object" .= parametersObject, "includeTrailingDelimiter" .= parametersIncludeTrailingDelimiter, "kmsKeyName" .= parametersKmsKeyName, "projection" .= parametersProjection, "serviceAccountEmail" .= parametersServiceAccountEmail, "permissions" .= parametersPermissions, "provisionalUserProject" .= parametersProvisionalUserProject, "pageToken" .= parametersPageToken, "projectId" .= parametersProjectId, "oauth_token" .= parametersOauthToken, "delimiter" .= parametersDelimiter, "sourceGeneration" .= parametersSourceGeneration, "entity" .= parametersEntity, "generation" .= parametersGeneration, "maxResults" .= parametersMaxResults, "accessId" .= parametersAccessId, "destinationKmsKeyName" .= parametersDestinationKmsKeyName, "fields" .= parametersFields, "alt" .= parametersAlt, "rewriteToken" .= parametersRewriteToken, "destinationObject" .= parametersDestinationObject]
  toEncoding (Parameters {..}) = pairs  ("destinationPredefinedAcl" .= parametersDestinationPredefinedAcl<>"quotaUser" .= parametersQuotaUser<>"ifSourceGenerationMatch" .= parametersIfSourceGenerationMatch<>"ifMetagenerationMatch" .= parametersIfMetagenerationMatch<>"ifGenerationNotMatch" .= parametersIfGenerationNotMatch<>"prettyPrint" .= parametersPrettyPrint<>"ifSourceMetagenerationNotMatch" .= parametersIfSourceMetagenerationNotMatch<>"ifSourceMetagenerationMatch" .= parametersIfSourceMetagenerationMatch<>"showDeletedKeys" .= parametersShowDeletedKeys<>"ifGenerationMatch" .= parametersIfGenerationMatch<>"startOffset" .= parametersStartOffset<>"project" .= parametersProject<>"notification" .= parametersNotification<>"prefix" .= parametersPrefix<>"userIp" .= parametersUserIp<>"predefinedAcl" .= parametersPredefinedAcl<>"sourceObject" .= parametersSourceObject<>"maxBytesRewrittenPerCall" .= parametersMaxBytesRewrittenPerCall<>"sourceBucket" .= parametersSourceBucket<>"bucket" .= parametersBucket<>"predefinedDefaultObjectAcl" .= parametersPredefinedDefaultObjectAcl<>"versions" .= parametersVersions<>"userProject" .= parametersUserProject<>"key" .= parametersKey<>"name" .= parametersName<>"destinationBucket" .= parametersDestinationBucket<>"optionsRequestedPolicyVersion" .= parametersOptionsRequestedPolicyVersion<>"ifMetagenerationNotMatch" .= parametersIfMetagenerationNotMatch<>"ifSourceGenerationNotMatch" .= parametersIfSourceGenerationNotMatch<>"contentEncoding" .= parametersContentEncoding<>"endOffset" .= parametersEndOffset<>"object" .= parametersObject<>"includeTrailingDelimiter" .= parametersIncludeTrailingDelimiter<>"kmsKeyName" .= parametersKmsKeyName<>"projection" .= parametersProjection<>"serviceAccountEmail" .= parametersServiceAccountEmail<>"permissions" .= parametersPermissions<>"provisionalUserProject" .= parametersProvisionalUserProject<>"pageToken" .= parametersPageToken<>"projectId" .= parametersProjectId<>"oauth_token" .= parametersOauthToken<>"delimiter" .= parametersDelimiter<>"sourceGeneration" .= parametersSourceGeneration<>"entity" .= parametersEntity<>"generation" .= parametersGeneration<>"maxResults" .= parametersMaxResults<>"accessId" .= parametersAccessId<>"destinationKmsKeyName" .= parametersDestinationKmsKeyName<>"fields" .= parametersFields<>"alt" .= parametersAlt<>"rewriteToken" .= parametersRewriteToken<>"destinationObject" .= parametersDestinationObject)


data Request = Request { 
    requestRef :: Text,
    requestParameterName :: (Maybe (Text:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Request where
  parseJSON (Object v) = Request <$> v .:  "$ref" <*> v .:? "parameterName"
  parseJSON _          = mzero


instance ToJSON Request where
  toJSON     (Request {..}) = object ["$ref" .= requestRef, "parameterName" .= requestParameterName]
  toEncoding (Request {..}) = pairs  ("$ref" .= requestRef<>"parameterName" .= requestParameterName)


data Insert = Insert { 
    insertParameterOrder :: [Text],
    insertMediaUpload :: (Maybe (MediaUpload:|:[(Maybe Value)])),
    insertHttpMethod :: Text,
    insertPath :: Text,
    insertResponse :: Response:|:[(Maybe Value)],
    insertSupportsMediaUpload :: (Maybe (Bool:|:[(Maybe Value)])),
    insertScopes :: [Text],
    insertParameters :: Parameters:|:[(Maybe Value)],
    insertId :: Text,
    insertDescription :: Text,
    insertRequest :: Request:|:[(Maybe Value)]
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Insert where
  parseJSON (Object v) = Insert <$> v .:  "parameterOrder" <*> v .:? "mediaUpload" <*> v .:  "httpMethod" <*> v .:  "path" <*> v .:  "response" <*> v .:? "supportsMediaUpload" <*> v .:  "scopes" <*> v .:  "parameters" <*> v .:  "id" <*> v .:  "description" <*> v .:  "request"
  parseJSON _          = mzero


instance ToJSON Insert where
  toJSON     (Insert {..}) = object ["parameterOrder" .= insertParameterOrder, "mediaUpload" .= insertMediaUpload, "httpMethod" .= insertHttpMethod, "path" .= insertPath, "response" .= insertResponse, "supportsMediaUpload" .= insertSupportsMediaUpload, "scopes" .= insertScopes, "parameters" .= insertParameters, "id" .= insertId, "description" .= insertDescription, "request" .= insertRequest]
  toEncoding (Insert {..}) = pairs  ("parameterOrder" .= insertParameterOrder<>"mediaUpload" .= insertMediaUpload<>"httpMethod" .= insertHttpMethod<>"path" .= insertPath<>"response" .= insertResponse<>"supportsMediaUpload" .= insertSupportsMediaUpload<>"scopes" .= insertScopes<>"parameters" .= insertParameters<>"id" .= insertId<>"description" .= insertDescription<>"request" .= insertRequest)


data List = List { 
    listParameterOrder :: [Text],
    listHttpMethod :: Text,
    listPath :: Text,
    listResponse :: Response:|:[(Maybe Value)],
    listScopes :: [Text],
    listSupportsSubscription :: (Maybe (Bool:|:[(Maybe Value)])),
    listParameters :: Parameters:|:[(Maybe Value)],
    listId :: Text,
    listDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON List where
  parseJSON (Object v) = List <$> v .:  "parameterOrder" <*> v .:  "httpMethod" <*> v .:  "path" <*> v .:  "response" <*> v .:  "scopes" <*> v .:? "supportsSubscription" <*> v .:  "parameters" <*> v .:  "id" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON List where
  toJSON     (List {..}) = object ["parameterOrder" .= listParameterOrder, "httpMethod" .= listHttpMethod, "path" .= listPath, "response" .= listResponse, "scopes" .= listScopes, "supportsSubscription" .= listSupportsSubscription, "parameters" .= listParameters, "id" .= listId, "description" .= listDescription]
  toEncoding (List {..}) = pairs  ("parameterOrder" .= listParameterOrder<>"httpMethod" .= listHttpMethod<>"path" .= listPath<>"response" .= listResponse<>"scopes" .= listScopes<>"supportsSubscription" .= listSupportsSubscription<>"parameters" .= listParameters<>"id" .= listId<>"description" .= listDescription)


data Update = Update { 
    updateParameterOrder :: [Text],
    updateHttpMethod :: Text,
    updatePath :: Text,
    updateResponse :: Response:|:[(Maybe Value)],
    updateScopes :: [Text],
    updateParameters :: Parameters:|:[(Maybe Value)],
    updateId :: Text,
    updateDescription :: Text,
    updateRequest :: Request:|:[(Maybe Value)]
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Update where
  parseJSON (Object v) = Update <$> v .:  "parameterOrder" <*> v .:  "httpMethod" <*> v .:  "path" <*> v .:  "response" <*> v .:  "scopes" <*> v .:  "parameters" <*> v .:  "id" <*> v .:  "description" <*> v .:  "request"
  parseJSON _          = mzero


instance ToJSON Update where
  toJSON     (Update {..}) = object ["parameterOrder" .= updateParameterOrder, "httpMethod" .= updateHttpMethod, "path" .= updatePath, "response" .= updateResponse, "scopes" .= updateScopes, "parameters" .= updateParameters, "id" .= updateId, "description" .= updateDescription, "request" .= updateRequest]
  toEncoding (Update {..}) = pairs  ("parameterOrder" .= updateParameterOrder<>"httpMethod" .= updateHttpMethod<>"path" .= updatePath<>"response" .= updateResponse<>"scopes" .= updateScopes<>"parameters" .= updateParameters<>"id" .= updateId<>"description" .= updateDescription<>"request" .= updateRequest)


data WatchAll = WatchAll { 
    watchAllParameterOrder :: [Text],
    watchAllHttpMethod :: Text,
    watchAllPath :: Text,
    watchAllResponse :: Response,
    watchAllScopes :: [Text],
    watchAllSupportsSubscription :: Bool,
    watchAllParameters :: Parameters,
    watchAllId :: Text,
    watchAllDescription :: Text,
    watchAllRequest :: Request
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON WatchAll where
  parseJSON (Object v) = WatchAll <$> v .:  "parameterOrder" <*> v .:  "httpMethod" <*> v .:  "path" <*> v .:  "response" <*> v .:  "scopes" <*> v .:  "supportsSubscription" <*> v .:  "parameters" <*> v .:  "id" <*> v .:  "description" <*> v .:  "request"
  parseJSON _          = mzero


instance ToJSON WatchAll where
  toJSON     (WatchAll {..}) = object ["parameterOrder" .= watchAllParameterOrder, "httpMethod" .= watchAllHttpMethod, "path" .= watchAllPath, "response" .= watchAllResponse, "scopes" .= watchAllScopes, "supportsSubscription" .= watchAllSupportsSubscription, "parameters" .= watchAllParameters, "id" .= watchAllId, "description" .= watchAllDescription, "request" .= watchAllRequest]
  toEncoding (WatchAll {..}) = pairs  ("parameterOrder" .= watchAllParameterOrder<>"httpMethod" .= watchAllHttpMethod<>"path" .= watchAllPath<>"response" .= watchAllResponse<>"scopes" .= watchAllScopes<>"supportsSubscription" .= watchAllSupportsSubscription<>"parameters" .= watchAllParameters<>"id" .= watchAllId<>"description" .= watchAllDescription<>"request" .= watchAllRequest)


data TestIamPermissions = TestIamPermissions { 
    testIamPermissionsParameterOrder :: [Text],
    testIamPermissionsHttpMethod :: Text,
    testIamPermissionsPath :: Text,
    testIamPermissionsResponse :: Response:|:[(Maybe Value)],
    testIamPermissionsScopes :: [Text],
    testIamPermissionsParameters :: Parameters:|:[(Maybe Value)],
    testIamPermissionsId :: Text,
    testIamPermissionsDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON TestIamPermissions where
  parseJSON (Object v) = TestIamPermissions <$> v .:  "parameterOrder" <*> v .:  "httpMethod" <*> v .:  "path" <*> v .:  "response" <*> v .:  "scopes" <*> v .:  "parameters" <*> v .:  "id" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON TestIamPermissions where
  toJSON     (TestIamPermissions {..}) = object ["parameterOrder" .= testIamPermissionsParameterOrder, "httpMethod" .= testIamPermissionsHttpMethod, "path" .= testIamPermissionsPath, "response" .= testIamPermissionsResponse, "scopes" .= testIamPermissionsScopes, "parameters" .= testIamPermissionsParameters, "id" .= testIamPermissionsId, "description" .= testIamPermissionsDescription]
  toEncoding (TestIamPermissions {..}) = pairs  ("parameterOrder" .= testIamPermissionsParameterOrder<>"httpMethod" .= testIamPermissionsHttpMethod<>"path" .= testIamPermissionsPath<>"response" .= testIamPermissionsResponse<>"scopes" .= testIamPermissionsScopes<>"parameters" .= testIamPermissionsParameters<>"id" .= testIamPermissionsId<>"description" .= testIamPermissionsDescription)


data Get = Get { 
    getSupportsMediaDownload :: (Maybe (Bool:|:[(Maybe Value)])),
    getParameterOrder :: [Text],
    getHttpMethod :: Text,
    getPath :: Text,
    getResponse :: Response:|:[(Maybe Value)],
    getScopes :: [Text],
    getParameters :: Parameters:|:[(Maybe Value)],
    getId :: Text,
    getUseMediaDownloadService :: (Maybe (Bool:|:[(Maybe Value)])),
    getDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Get where
  parseJSON (Object v) = Get <$> v .:? "supportsMediaDownload" <*> v .:  "parameterOrder" <*> v .:  "httpMethod" <*> v .:  "path" <*> v .:  "response" <*> v .:  "scopes" <*> v .:  "parameters" <*> v .:  "id" <*> v .:? "useMediaDownloadService" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Get where
  toJSON     (Get {..}) = object ["supportsMediaDownload" .= getSupportsMediaDownload, "parameterOrder" .= getParameterOrder, "httpMethod" .= getHttpMethod, "path" .= getPath, "response" .= getResponse, "scopes" .= getScopes, "parameters" .= getParameters, "id" .= getId, "useMediaDownloadService" .= getUseMediaDownloadService, "description" .= getDescription]
  toEncoding (Get {..}) = pairs  ("supportsMediaDownload" .= getSupportsMediaDownload<>"parameterOrder" .= getParameterOrder<>"httpMethod" .= getHttpMethod<>"path" .= getPath<>"response" .= getResponse<>"scopes" .= getScopes<>"parameters" .= getParameters<>"id" .= getId<>"useMediaDownloadService" .= getUseMediaDownloadService<>"description" .= getDescription)


data Stop = Stop { 
    stopHttpMethod :: Text,
    stopPath :: Text,
    stopScopes :: [Text],
    stopId :: Text,
    stopDescription :: Text,
    stopRequest :: Request
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Stop where
  parseJSON (Object v) = Stop <$> v .:  "httpMethod" <*> v .:  "path" <*> v .:  "scopes" <*> v .:  "id" <*> v .:  "description" <*> v .:  "request"
  parseJSON _          = mzero


instance ToJSON Stop where
  toJSON     (Stop {..}) = object ["httpMethod" .= stopHttpMethod, "path" .= stopPath, "scopes" .= stopScopes, "id" .= stopId, "description" .= stopDescription, "request" .= stopRequest]
  toEncoding (Stop {..}) = pairs  ("httpMethod" .= stopHttpMethod<>"path" .= stopPath<>"scopes" .= stopScopes<>"id" .= stopId<>"description" .= stopDescription<>"request" .= stopRequest)


data Delete = Delete { 
    deleteParameterOrder :: [Text],
    deleteHttpMethod :: Text,
    deletePath :: Text,
    deleteScopes :: [Text],
    deleteParameters :: Parameters:|:[(Maybe Value)],
    deleteId :: Text,
    deleteDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Delete where
  parseJSON (Object v) = Delete <$> v .:  "parameterOrder" <*> v .:  "httpMethod" <*> v .:  "path" <*> v .:  "scopes" <*> v .:  "parameters" <*> v .:  "id" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Delete where
  toJSON     (Delete {..}) = object ["parameterOrder" .= deleteParameterOrder, "httpMethod" .= deleteHttpMethod, "path" .= deletePath, "scopes" .= deleteScopes, "parameters" .= deleteParameters, "id" .= deleteId, "description" .= deleteDescription]
  toEncoding (Delete {..}) = pairs  ("parameterOrder" .= deleteParameterOrder<>"httpMethod" .= deleteHttpMethod<>"path" .= deletePath<>"scopes" .= deleteScopes<>"parameters" .= deleteParameters<>"id" .= deleteId<>"description" .= deleteDescription)


data Methods = Methods { 
    methodsInsert :: (Maybe (Insert:|:[(Maybe Value)])),
    methodsList :: (Maybe (List:|:[(Maybe Value)])),
    methodsCopy :: (Maybe (Update:|:[(Maybe Value)])),
    methodsWatchAll :: (Maybe (WatchAll:|:[(Maybe Value)])),
    methodsGetIamPolicy :: (Maybe (TestIamPermissions:|:[(Maybe Value)])),
    methodsPatch :: (Maybe (Update:|:[(Maybe Value)])),
    methodsGet :: (Maybe (Get:|:[(Maybe Value)])),
    methodsCreate :: (Maybe (TestIamPermissions:|:[(Maybe Value)])),
    methodsSetIamPolicy :: (Maybe (Update:|:[(Maybe Value)])),
    methodsLockRetentionPolicy :: (Maybe (TestIamPermissions:|:[(Maybe Value)])),
    methodsRewrite :: (Maybe (Update:|:[(Maybe Value)])),
    methodsCompose :: (Maybe (Update:|:[(Maybe Value)])),
    methodsStop :: (Maybe (Stop:|:[(Maybe Value)])),
    methodsTestIamPermissions :: (Maybe (TestIamPermissions:|:[(Maybe Value)])),
    methodsDelete :: (Maybe (Delete:|:[(Maybe Value)])),
    methodsUpdate :: (Maybe (Update:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Methods where
  parseJSON (Object v) = Methods <$> v .:? "insert" <*> v .:? "list" <*> v .:? "copy" <*> v .:? "watchAll" <*> v .:? "getIamPolicy" <*> v .:? "patch" <*> v .:? "get" <*> v .:? "create" <*> v .:? "setIamPolicy" <*> v .:? "lockRetentionPolicy" <*> v .:? "rewrite" <*> v .:? "compose" <*> v .:? "stop" <*> v .:? "testIamPermissions" <*> v .:? "delete" <*> v .:? "update"
  parseJSON _          = mzero


instance ToJSON Methods where
  toJSON     (Methods {..}) = object ["insert" .= methodsInsert, "list" .= methodsList, "copy" .= methodsCopy, "watchAll" .= methodsWatchAll, "getIamPolicy" .= methodsGetIamPolicy, "patch" .= methodsPatch, "get" .= methodsGet, "create" .= methodsCreate, "setIamPolicy" .= methodsSetIamPolicy, "lockRetentionPolicy" .= methodsLockRetentionPolicy, "rewrite" .= methodsRewrite, "compose" .= methodsCompose, "stop" .= methodsStop, "testIamPermissions" .= methodsTestIamPermissions, "delete" .= methodsDelete, "update" .= methodsUpdate]
  toEncoding (Methods {..}) = pairs  ("insert" .= methodsInsert<>"list" .= methodsList<>"copy" .= methodsCopy<>"watchAll" .= methodsWatchAll<>"getIamPolicy" .= methodsGetIamPolicy<>"patch" .= methodsPatch<>"get" .= methodsGet<>"create" .= methodsCreate<>"setIamPolicy" .= methodsSetIamPolicy<>"lockRetentionPolicy" .= methodsLockRetentionPolicy<>"rewrite" .= methodsRewrite<>"compose" .= methodsCompose<>"stop" .= methodsStop<>"testIamPermissions" .= methodsTestIamPermissions<>"delete" .= methodsDelete<>"update" .= methodsUpdate)


data Notifications = Notifications { 
    notificationsMethods :: Methods:|:[(Maybe Value)]
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Notifications where
  parseJSON (Object v) = Notifications <$> v .:  "methods"
  parseJSON _          = mzero


instance ToJSON Notifications where
  toJSON     (Notifications {..}) = object ["methods" .= notificationsMethods]
  toEncoding (Notifications {..}) = pairs  ("methods" .= notificationsMethods)


data Projects = Projects { 
    projectsResources :: Resources
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Projects where
  parseJSON (Object v) = Projects <$> v .:  "resources"
  parseJSON _          = mzero


instance ToJSON Projects where
  toJSON     (Projects {..}) = object ["resources" .= projectsResources]
  toEncoding (Projects {..}) = pairs  ("resources" .= projectsResources)


data Resources = Resources { 
    resourcesBuckets :: (Maybe (Notifications:|:[(Maybe Value)])),
    resourcesChannels :: (Maybe (Notifications:|:[(Maybe Value)])),
    resourcesHmacKeys :: (Maybe (Notifications:|:[(Maybe Value)])),
    resourcesBucketAccessControls :: (Maybe (Notifications:|:[(Maybe Value)])),
    resourcesObjects :: (Maybe (Notifications:|:[(Maybe Value)])),
    resourcesDefaultObjectAccessControls :: (Maybe (Notifications:|:[(Maybe Value)])),
    resourcesServiceAccount :: (Maybe (Notifications:|:[(Maybe Value)])),
    resourcesObjectAccessControls :: (Maybe (Notifications:|:[(Maybe Value)])),
    resourcesNotifications :: (Maybe (Notifications:|:[(Maybe Value)])),
    resourcesProjects :: (Maybe (Projects:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Resources where
  parseJSON (Object v) = Resources <$> v .:? "buckets" <*> v .:? "channels" <*> v .:? "hmacKeys" <*> v .:? "bucketAccessControls" <*> v .:? "objects" <*> v .:? "defaultObjectAccessControls" <*> v .:? "serviceAccount" <*> v .:? "objectAccessControls" <*> v .:? "notifications" <*> v .:? "projects"
  parseJSON _          = mzero


instance ToJSON Resources where
  toJSON     (Resources {..}) = object ["buckets" .= resourcesBuckets, "channels" .= resourcesChannels, "hmacKeys" .= resourcesHmacKeys, "bucketAccessControls" .= resourcesBucketAccessControls, "objects" .= resourcesObjects, "defaultObjectAccessControls" .= resourcesDefaultObjectAccessControls, "serviceAccount" .= resourcesServiceAccount, "objectAccessControls" .= resourcesObjectAccessControls, "notifications" .= resourcesNotifications, "projects" .= resourcesProjects]
  toEncoding (Resources {..}) = pairs  ("buckets" .= resourcesBuckets<>"channels" .= resourcesChannels<>"hmacKeys" .= resourcesHmacKeys<>"bucketAccessControls" .= resourcesBucketAccessControls<>"objects" .= resourcesObjects<>"defaultObjectAccessControls" .= resourcesDefaultObjectAccessControls<>"serviceAccount" .= resourcesServiceAccount<>"objectAccessControls" .= resourcesObjectAccessControls<>"notifications" .= resourcesNotifications<>"projects" .= resourcesProjects)


data Document = Document { 
    documentEtag :: Text,
    documentSchemas :: Schemas,
    documentServicePath :: Text,
    documentBasePath :: Text,
    documentKind :: Text,
    documentAuth :: Auth,
    documentIcons :: Icons,
    documentBaseUrl :: Text,
    documentProtocol :: Text,
    documentOwnerName :: Text,
    documentResources :: Resources,
    documentOwnerDomain :: Text,
    documentBatchPath :: Text,
    documentName :: Text,
    documentVersion :: Text,
    documentParameters :: Parameters,
    documentDocumentationLink :: Text,
    documentRootUrl :: Text,
    documentId :: Text,
    documentLabels :: [Text],
    documentDiscoveryVersion :: Text,
    documentTitle :: Text,
    documentRevision :: Text,
    documentDescription :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Document where
  parseJSON (Object v) = Document <$> v .:  "etag" <*> v .:  "schemas" <*> v .:  "servicePath" <*> v .:  "basePath" <*> v .:  "kind" <*> v .:  "auth" <*> v .:  "icons" <*> v .:  "baseUrl" <*> v .:  "protocol" <*> v .:  "ownerName" <*> v .:  "resources" <*> v .:  "ownerDomain" <*> v .:  "batchPath" <*> v .:  "name" <*> v .:  "version" <*> v .:  "parameters" <*> v .:  "documentationLink" <*> v .:  "rootUrl" <*> v .:  "id" <*> v .:  "labels" <*> v .:  "discoveryVersion" <*> v .:  "title" <*> v .:  "revision" <*> v .:  "description"
  parseJSON _          = mzero


instance ToJSON Document where
  toJSON     (Document {..}) = object ["etag" .= documentEtag, "schemas" .= documentSchemas, "servicePath" .= documentServicePath, "basePath" .= documentBasePath, "kind" .= documentKind, "auth" .= documentAuth, "icons" .= documentIcons, "baseUrl" .= documentBaseUrl, "protocol" .= documentProtocol, "ownerName" .= documentOwnerName, "resources" .= documentResources, "ownerDomain" .= documentOwnerDomain, "batchPath" .= documentBatchPath, "name" .= documentName, "version" .= documentVersion, "parameters" .= documentParameters, "documentationLink" .= documentDocumentationLink, "rootUrl" .= documentRootUrl, "id" .= documentId, "labels" .= documentLabels, "discoveryVersion" .= documentDiscoveryVersion, "title" .= documentTitle, "revision" .= documentRevision, "description" .= documentDescription]
  toEncoding (Document {..}) = pairs  ("etag" .= documentEtag<>"schemas" .= documentSchemas<>"servicePath" .= documentServicePath<>"basePath" .= documentBasePath<>"kind" .= documentKind<>"auth" .= documentAuth<>"icons" .= documentIcons<>"baseUrl" .= documentBaseUrl<>"protocol" .= documentProtocol<>"ownerName" .= documentOwnerName<>"resources" .= documentResources<>"ownerDomain" .= documentOwnerDomain<>"batchPath" .= documentBatchPath<>"name" .= documentName<>"version" .= documentVersion<>"parameters" .= documentParameters<>"documentationLink" .= documentDocumentationLink<>"rootUrl" .= documentRootUrl<>"id" .= documentId<>"labels" .= documentLabels<>"discoveryVersion" .= documentDiscoveryVersion<>"title" .= documentTitle<>"revision" .= documentRevision<>"description" .= documentDescription)





-- | Use parser to get Document object
{--
parse :: FilePath -> IO Document
parse filename = do
    input <- BSL.readFile filename
    case eitherDecode input of
      Left errTop -> fatal $ case (eitherDecode input :: Either String Value) of
                           Left  err -> "Invalid JSON file: " ++ filename ++ "\n   " ++ err
                           Right _   -> "Mismatched JSON value from file: " ++ filename
                                     ++ "\n" ++ errTop
      Right r     -> return (r :: Document)
  where
    fatal :: String -> IO a
    fatal msg = do hPutStrLn stderr msg
                   exitFailure

-- | For quick testing
main :: IO ()
main = do
  filenames <- getArgs
  forM_ filenames (\f -> parse f >>= (\p -> p `seq` putStrLn $ "Successfully parsed " ++ f))
  exitSuccess

--}
